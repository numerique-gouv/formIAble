"""
Module for automatically filling in pdf forms
"""

import json
import os
import random
import uuid
from collections import OrderedDict
from enum import Enum

import numpy as np
import numpy.random
from faker import Faker
from faker_vehicle import VehicleProvider
from fitz import fitz
from jsonlines import jsonlines

from src.util.utils import pdf_to_image

locales = OrderedDict([
    ('fr-FR', 1)])



class DateFormats(Enum):
    """
    Enum class defining the possible date formats to use in text areas.
    """
    NUMERIC = ['%d-%m-%Y', '%d/%m/%Y', '%d-%m-%y', '%d/%m/%Y']
    STR = ['%d %B %Y', '%d %B %y']
    NUMERIC_OR_STR = NUMERIC + STR

class Annotator():
    """
    Create a json file containing the labels associated with a pdf. The labels are the values automatically
    generated by the Writer.
    """
    def __init__(self):
        self.dic = {}
        self.filename = None

class AnnotatorTxt(Annotator):
    """
    Create a json file containing the labels associated with a pdf. The labels are the values automatically
    generated by the Writer.
    """

    def __init__(self):
        super().__init__()
        self.fields = []
        self.extension = ".txt"

    def add(self, field):
        """
        Ajout d'un champs à la liste finale d'annotations
        :param field: Le widget à annoter
        :return:
        """
        self.fields.append([(field.rect.top_left.x, field.rect.top_left.y),
                            (field.rect.bottom_right.x, field.rect.bottom_right.y),
                            field.field_type_string,
                            field.field_name,
                            field.field_value]
                           )
        # [(15, 328), (225, 369), 'text', 'name']

    def save(self, filename:str, dataset:None):
        """
        Sauvegarde des annotations
        :param filename: Nom du fichier où sauvegarder
        :return:
        """
        self.filename = filename +".txt"

        with open(self.filename, 'w', encoding="utf-8") as fp:
            for field in self.fields:
                fp.write(f"{field}\n")


class AnnotatorJson(Annotator):
    """
    Create a json file containing the labels associated with a pdf. The labels are the values automatically
    generated by the Writer.
    """

    def __init__(self):
        super().__init__()
        self.dic = {}
        self.extension = ".json"

    def add(self, field):
        """
        Ajout d'un champs au dictionnaire final d'annotations
        :param field: Le widget à annoter
        :param loc: Les coordonnées du widget
        :param value: Valeur à lire par l'OCR
        :return:
        """
        self.dic.update({ str(field.rect):(field.field_name,field.field_value, field.field_type_string)})

    def save(self, filename:str, dataset:None):
        """
        Sauvegarde des annotations
        :param filename: Nom du fichier où sauvegarder
        :return:
        """
        self.filename = filename +".json"
        with open(self.filename, "w", encoding="utf-8") as file:
            json.dump(self.dic,file)


class AnnotatorJsonDonut(Annotator):
    """
        Create a json file containing the labels associated with a pdf.
        The labels are the values automatically generated by the Writer.
        This annotator follows the json format expected to train donut models.
        """

    def __init__(self):
        super().__init__()
        self.dic = {}
        self.extension = ".json"

    def add(self, field):
        """
        Ajout d'un champs au dictionnaire final d'annotations
        :param field: Le widget à annoter
        :return:
        """
        self.dic.update({ field.field_name : field.field_value})

    def __save_tmp_json__(self, filename:str, dataset:str):
        self.pdf_filename_without_extension = filename

        json_tmp_path_as_list = self.pdf_filename_without_extension.split('/')[:-1] + [ "tmp"]
        json_tmp_path = os.sep.join(json_tmp_path_as_list)

        json_tmp_file = self.pdf_filename_without_extension.split('/')[-1]
        json_file = os.sep.join([json_tmp_path, json_tmp_file + self.extension])

        if not os.path.exists(json_tmp_path):
            os.makedirs(json_tmp_path)

        with open(json_file, "w", encoding="utf-8") as file:
            json.dump(self.dic,file)

        return json_tmp_path, json_file

    def __convert_pdf_to_images(self, folder):
        input_folder = folder
        output_folder = folder
        pdf_to_image(input_folder, output_folder)

    def save(self, filepath:str, dataset:str):
        """
        Sauvegarde des annotations
        :param filepath: Nom du fichier où sauvegarder
        :return:
        """

        json_tmp_path, json_file = self.__save_tmp_json__(filepath, dataset)
        jsonl_dir = json_tmp_path + f"/.."
        jsonl_filepath = jsonl_dir + "/metadata.jsonl"

        with open(json_file, "r") as f:
            data = json.loads(f.read())

        if not os.path.exists(jsonl_dir):
            os.makedirs(jsonl_dir)

        with jsonlines.open(jsonl_filepath, mode='a') as writer:
            # inner_dic = {"gt_parse": json.dumps(data) }
            inner_dic = {"gt_parse": data}

            filename = filepath.split('/')[-1]
            line = { "file_name": filename + '.jpg',
                     "ground_truth": json.dumps(inner_dic)
                   }
            writer.write(line)

        import shutil
        shutil.rmtree(json_tmp_path)





class Writer:
    """
    Before creating a new writer, you need to place a cerfa_{num_cerfa}.pdf file and cerfa_{num_cerfa}.json
    file into folder data/CERFA/toFill. The pdf file is the empty template, and the json file is the mapping
    indicating the semantic for each text field. You need to extend this Writer with a child classe dedicated to
    the cerfa you want. In the __init__ of the child class, you need to specify a dictionnary D mapping field types
    with functions to fill them.
    """
    @classmethod
    def get_subclasses(cls):
        for subclass in cls.__subclasses__():
            yield subclass

    def __init__(self, num_cerfa:str, annotator:Annotator = None, shift_coeff:float=None):
        """
        In the __init__ of the child class, you need to specify a dictionnary D mapping field types
        with functions to fill them.
        :param num_cerfa: cerfa number as string.
        :param shift_coeff float: Coefficient déterminant le pourcentage de décalage admissible pour les text_box (voir
        self.__shit_textbox__)
        """
        self.fake = Faker(locales)
        self.fake.add_provider(VehicleProvider)
        _input_filepath = f"data/empty_forms/editable/cerfa_{num_cerfa}.pdf"
        _param_filepath = f"data/elements_to_fill_forms/editable/cerfa_{num_cerfa}.json"
        if isinstance(annotator, AnnotatorJsonDonut):
            self.output_filepath = "output/{}/{}/{}.pdf"
        else:
            self.output_filepath = "output/{}/cerfa_{}_v{}.pdf"

        self.doc = fitz.open(_input_filepath)

        self.params = json.load(open(_param_filepath, 'rb'))
        self.num_cerfa = num_cerfa

        self.__set_text_style__()

        self.radio_buttons_values = {}
        self.radio_buttons_group_len = {}
        self.__clear_radio_buttons__()
        self.D = {}
        self.annotator = annotator

    def __set_text_style__(self, rgb_max:float = 0.8, min_size:float = 6, max_size:float = 13):
        """
        Génération aléatoire de style de texte à partir de
            * liste de fonts pris en charge
            * couleur aléatoire
            * taille aléatoire entre 6 et 13
        En introduisant de la variabilité, on espère rendre le moule OCR plus robuste.

        :param rgb_max: Maximum pour les valeurs Red, Green, Blue de la couleur du texte. Si R=G=B=1, alors couleur du
        texte = blanc, et le texte sera illisible. Par défaut, rbg_max = 0.8
        :param min_size: Taille minimale du texte (en pt). Par défaut, min_size=6
        :param max_size: Taille maximale du texte (en pt). Par défaut, max_size=13
        :return:
        """
        with open("data/elements_to_fill_forms/editable/usable_fonts.json", "r", encoding='utf-8') as file:
            usable_fonts = [x.lower() for x in list(json.loads(file.read()).keys())]
            font = numpy.random.choice(usable_fonts)
            self.doc[0].insert_font(fontname=font, encoding=0)
            self.font = fitz.Font(font)
        # La couleur est définie sous forme de triplet (RGB), dont les valeurs sont ramenées entre 0 et 1.
        # => On génère un triplet aléatoire de valeurs dans [0;0.8] pour ne pas avoir de couleur trop claires
        self.font_color = list(numpy.random.uniform(0, rgb_max, size=3))
        self.font_size = numpy.random.randint(min_size, max_size)

    def __clear_radio_buttons__(self):
        """
        Deactivate all radio buttons on the form before processing the file.
        :return: None
        """
        for p in range(self.doc.page_count):
            page = self.doc[p]
            _field = page.first_widget

            while _field:
                if _field.field_type == 5:
                    _field.field_value = 0
                    _field.update()
                    group_len = self.radio_buttons_group_len.get(_field.field_name, 0)
                    self.radio_buttons_group_len[_field.field_name] = group_len + 1
                _field = _field.next

    def __shift_textbox__(self, rect: fitz.fitz.Rect, shift_coeff:float = 0.03):
        """
        Déplace aléatoirement d'un rectangle. Utilisé pour déplacer les boites de textes contenant les valeurs à saisir
        par les utilisateurs du CERFA. En introduisant de la variabilité, on espère rendre le moule OCR plus robuste.
        :param rect fitz.fitz.Rect: Rectangle à déplacer
        :param shift_coeff float: Pourcentage de déplacement horizontal (resp. vertical) autorisé, exprimé par rapport à
         la largeur (resp. hauteur) du rectangle.
        :return: Le rectangle de la boite de texte assigné à sa nouvelle position
        """

        x_bound = shift_coeff * rect.width
        y_bound = shift_coeff * rect.height

        new_top_left_x = next(iter([numpy.random.uniform(rect.top_left.x - x_bound, rect.top_left.x + x_bound)]),None)
        new_top_left_y = next(iter([numpy.random.uniform(rect.top_left.y - y_bound, rect.top_left.y + y_bound)]),None)

        dx = rect.top_left.x - new_top_left_x
        dy = rect.top_left.y - new_top_left_y

        rect.x0 = new_top_left_x
        rect.y0 = new_top_left_y
        rect.x1 = rect.x1 + dx
        rect.y1 = rect.y1 + dy

        return rect

    # -----------------------------------------------------------------------------------------------------------
    # The following functions fill the different kind of widgets : text, checkbox, radio ...
    # -----------------------------------------------------------------------------------------------------------
    def fill_text(self, field:fitz.fitz.Widget):
        """
        Fills a text area with a value depending on the mapping defined in the self.D dictionary,
        and the json file associated to the pdf.

        :param fitz.fitz.Widget field: The widget we want to fill (text area in this case)
        :return: None
        """

        # Apply random style & position variations
        field.text_font = self.font.name
        field.text_color = self.font_color
        field.text_fontsize = self.font_size

        # TODO convertir en log debug
        # print("-" * 20)
        # print(field.rect)

        field.rect = self.__shift_textbox__(field.rect)
        # TODO convertir en log debug
        # print(field.rect)
        # print("-" * 20)

        for key in self.D.keys():
            values = self.params.get(key, None)
            if values and isinstance(values, list):
                if any(value.lower() in field.field_name.lower() for value in values):
                    try:  # Faker functions are called without argument
                        val = self.D[key]()
                    except KeyError:  # Writer's own functions may contain arguments
                        val = self.D[key](field=field)
                    field.field_value = val
                    field.update()
                    # self.annotator.add(field.field_name, field.rect, val)
                    self.annotator.add(field)
                    break

            elif values and isinstance(values, dict):
                for k in values.keys():
                    if k.lower() in field.field_name.lower():
                        # val = self.D[key]({"field": field, "param_value": values[k]})
                        val = self.D[key](field= field, param_value = values[k])
                        field.field_value = str(val)
                        field.update()
                        break

    def fill_checkbox(self, _field):
        """
        Automatically fill all checkboxes with a 50/50 chance
        :param fitz.fitz.Widget _field: Text box we want to process
        :return: None
        """
        val = self.fake.boolean(chance_of_getting_true=50)
        _field.field_value = val
        _field.update()
        self.annotator.add(_field)

    def fill_radio(self, _field):
        """
        Automatically fill all radio groups according to uniform law
        :param fitz.fitz.Widget _field: The radio button we want to process
        :return: None
        """
        if _field is None:
            return
        # We ensure that 1 and only 1 button within the group is activated
        group = self.radio_buttons_values.get(_field.field_name, np.array([]))
        group_already_has_active_button = any(group == 1)
        if not group_already_has_active_button:
            # If no button has been selected and this is the last one in the group => Activate it
            is_last_group_button = _field.next and _field.next.field_name != _field.field_name
            if is_last_group_button:
                val = 1
            else:
                # Proba to press button = 1 / nb_boutons
                chance_of_getting_true = 1 / self.radio_buttons_group_len[_field.field_name] * 100
                val = self.fake.boolean(chance_of_getting_true=chance_of_getting_true)
            # TODO: fix rather than ignore error
            try:
                _field.field_value = val
                _field.update()
                self.radio_buttons_values[_field.field_name] = np.insert(group, len(group), val)

                # self.annotator.add(_field.field_name, _field.rect, val)
                self.annotator.add(_field)
            except Exception:
                pass


    #TODO Add function to handle dropdown list

    # -----------------------------------------------------------------------------------------------------------
    # The following functions are helpers to fill a text box with specific semantics
    # -----------------------------------------------------------------------------------------------------------
    def fill_date(self, **kwargs):
        """
        Function used to fill a text area with a date, in a given format.
        :param fitz.fitz.Widget field: text area to fill
        :param str param_value: The format for the date. If empty, will use one random among
                    DateFormats.NUMERIC_OR_STR
        :return: The date to insert (as string)
        """
        try:
            _field, param_key = kwargs["field"], kwargs["param_value"]
        except KeyError as exc:
            raise KeyError("Function fill_date expects keyword arguments"
                           "'field' and 'param_value' Check docstring for details.") from exc

        _format = param_key
        if _format == "": _format = self.fake.random_element(elements=DateFormats.NUMERIC_OR_STR.value)
        return self.fake['fr-FR'].date(pattern=_format)

    def fill_paragraph(self, **kwargs):
        """
        Fill a text area with a paragraph containing between 1 and 3 sentences, and a maximum of 1000 characters.
        :param fitz.fitz.Widget field: text area to fill
        :return: The text to insert
        """
        _field = kwargs["field"]
        max_chars = _field.text_maxlen if _field.text_maxlen > 0 else 1000
        return self.fake['fr-FR'].paragraph(nb_sentences=3, variable_nb_sentences=True)[:max_chars]

    def fill_departement(self, **kwargs):
        _field, formats = kwargs["field"], kwargs["param_value"]
        if isinstance(formats,list):
            format = random.choice(formats)
            if format=='int':
                return self.fake['fr-FR'].department_number()
            elif format == "str":
                return self.fake['fr-FR'].department_name()

        raise ValueError("Vous devez spécifier une liste de formats admissible pour le champ décrivant le département"
                         "dans le fichier json (Formats possibles: int, str)")

    def fill_siren_siret(self):
        """
        Fill a text area with a siren or a siret (50/50 chance)
        :param fitz.fitz.Widget field: text area to fill
        :param kwargs: Not used. In the signature for compatibility reasons
        :return: siren or siret, with no spaces between digits
        """
        return self.fake['fr-FR'].siren().replace(" ", "") if self.fake.boolean(chance_of_getting_true=50) \
            else self.fake['fr-FR'].siret().replace(" ", "")

    def fill_siret(self):
        """
        Fill a text area with a siret
        :param kwargs: Not used. In the signature for compatibility reasons
        :return: The siret number with no space between digits
        """
        return self.fake['fr-FR'].siret().replace(" ", "")

    def fill_txt_pattern(self, **kwargs):
        """
        Call function bothify of faker with the required pattern.
        :param fitz.fitz.Widget field: text area to fill
        :param str param_value: The pattern to use

        :return: The string processed by bothify
        """
        _field, pattern = kwargs["field"], kwargs["param_value"]
        return self.fake.bothify(text=pattern)

    def fill_phone_number(self):
        """
        Returns faker's phone_number function after removing trailing '+' character, and all whitespaces
        :return: Un numéro de téléphone à 10 chiffres sans espaces
        """
        return self.fake['fr-FR'].phone_number().replace("+","").replace(" ","")

    def fill_digit_interval(self, **kwargs):
        """
        Sample a digit within a given interval.
        :param fitz.fitz.Widget field: text area to fill
        :param tuple param_value: A tuple containing the min/max bounds

        :return: The sampled number
        """
        _field, interval = kwargs["field"], kwargs["param_value"]
        _min, _max = interval
        return self.fake.random_int(_min, _max)

    def choice(self,**kwargs):
        """
        Select a random element within a list
        :param fitz.fitz.Widget field: text area to fill
        :param tuple param_value: The list of elements to choose from

        :return: The selected element
        """
        _field, choices = kwargs["field"], kwargs["param_value"]
        return self.fake.random_elements(elements=choices, length=1)[0]

    # -----------------------------------------------------------------------------------------------------------
    # The following functions iterate over the pages and fields of the form to fill it
    # -----------------------------------------------------------------------------------------------------------

    def fill_page(self, field):
        """
        Fill all the fields of pdf document's page
        :param fitz.fitz.Widget field: The first widget of the page
        :return: None
        """
        while field:
            if field.field_type == 7:
                self.fill_text(field)

            elif field.field_type == 5:
                self.fill_radio(field)

            elif field.field_type == 2:
                self.fill_checkbox(field)

            field = field.next

    def fill_form(self):
        """
        Fill all the pages of pdf form.
        :return: None
        """
        for p in range(self.doc.page_count):
            # if p in self.valid_pages:
            page = self.doc[p]
            field = page.first_widget
            if field:  # Aucun champs detecté sur la page, il s'agit d'une page de notice
                self.fill_page(field)
            else:
                self.doc.delete_page(p)

    # -----------------------------------------------------------------------------------------------------------
    # Save filled-in document on disk
    # -----------------------------------------------------------------------------------------------------------

    def save(self):
        """
        Save a form as pdf and its annotations as json into the output/{cerfa_number} directory.
        :return:
        """
        out_pdf = self.output_filepath.format(self.num_cerfa, self.num_cerfa, uuid.uuid4().hex)

        if not os.path.exists(out_pdf):
            os.makedirs(out_pdf)

        self.doc.save(out_pdf)
        labels_path = out_pdf[:-3] + "json"
        self.annotator.save(labels_path)

    def save_by_dataset(self, dataset):
        """
        Save a form as pdf and its annotations as json into the output/{cerfa_number} directory.
        :return:
        """

        out_pdf = self.output_filepath.format(self.num_cerfa,
                                                  dataset,
                                                  uuid.uuid4().hex)
        if not os.path.exists(out_pdf):
            os.makedirs(out_pdf)

        self.doc.save(out_pdf)
        labels_path = out_pdf[:-4]
        self.annotator.save(labels_path, dataset)